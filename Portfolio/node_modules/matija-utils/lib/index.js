"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.div = exports.diff = exports.onlyFalsy = exports.onlyTruthy = exports.shadeColor = exports.textEllipsis = exports.randomColorHex = exports.common = exports.acronym = exports.abbreviateNumber = exports.count = exports.difference = exports.zip = exports.generateRandomString = exports.sample = exports.randInt = exports.dateDiffReadable = exports.monthDiff = exports.getMonth = exports.end = exports.generateArray = exports.cloneObject = exports.repeat = exports.groupBy = exports.mod = exports.product = exports.sum = exports.splitByValue = exports.range = exports.chunk = exports.intersect = void 0;
const constants_1 = require("./constants");
/**
 * Finds the common elements of two arrays.
 * @param {any[]} a
 * @param {any[]} b
 * @example
 * intersect([1, 2, 3], [1, 2]); // [1, 2]
 */
const intersect = (a, b) => [...new Set(a)].filter((x) => new Set(b).has(x));
exports.intersect = intersect;
/**
 * Chunks an array into a new array consisting of smaller arrays of a specified size.
 * @param {any[]} arr
 * @param {number} chunkSize
 * @example
 * chunk([1, 2, 3, 4, 5, 6], 2); // [[1, 2], [3, 4], [5, 6]]
 */
const chunk = (arr, chunkSize) => {
    const result = [];
    for (let i = 0, len = arr.length; i < len; i += chunkSize)
        result.push(arr.slice(i, i + chunkSize));
    return result;
};
exports.chunk = chunk;
/**
 * Creates an array of numbers from a specified range.
 * @param {number} start
 * @param {number} end
 * @example
 * range(0, 5); // [0, 1, 2, 3, 4, 5]
 */
const range = (start, end) => {
    return Array(end - start + 1)
        .fill(0)
        .map((_, idx) => start + idx);
};
exports.range = range;
/**
 * Splits and clumps together an array of elements by using a separator.
 * @param {any[]} arr
 * @param {any} separator
 * @example
 * splitByValue([1, 2, 3, 4, "x", 5, 6, 7, 8], "x"); // [[1, 2, 3, 4], [5, 6, 7, 8]]
 */
const splitByValue = (arr, separator) => {
    const result = [[]];
    for (let i = 0; i < arr.length; i++)
        if (arr[i] == separator)
            result.push([]);
        else
            result[result.length - 1].push(arr[i]);
    return result;
};
exports.splitByValue = splitByValue;
/**
 * Sums an unspecified amount of inputs.
 * @param {...number} args
 * @example
 * sum(1, 2, 3); // 6
 */
const sum = (...args) => args.reduce((a, b) => a + b);
exports.sum = sum;
/**
 * Multiplies an unspecified amount of inputs.
 * @param {...number} args
 * @example
 * product(1, 2, 3); // 6
 */
const product = (...args) => args.reduce((a, b) => a * b);
exports.product = product;
/**
 * Performs a modulo operation akin to that of Python.
 * @see {@link https://docs.python.org/3.3/reference/expressions.html#binary-arithmetic-operations}
 * @param {number} a
 * @param {number} b
 * @example
 * mod(-2, 20); // 18
 */
const mod = (a, b) => ((a % b) + b) % b;
exports.mod = mod;
/**
 * Groups values in an array of objects by the provided property.
 * @param {T[]} array
 * @param {string} property
 * @return {IDictionary<T[]>} A dictionary with the key being the property and the value being the objects grouped by the provided property.
 * @example
 * const x = [{
 *   name: "Ivan",
 *   company: "Google"
 * },
 * {
 *   name: "Kenny",
 *   company: "Google"
 * },
 * {
 *   name: "Joseph",
 *   company: "Amazon"
 * }];
 *groupBy(x, "company");
 *
 * {
 *   "Google": [{
 *     "name": "Ivan",
 *     "company": "Google"
 *   },
 *   {
 *     "name": "Kenny",
 *     "company": "Google"
 *   }],
 *   "Amazon": [{
 *     "name": "Joseph",
 *     "company": "Amazon"
 *   }]
 * }
 */
const groupBy = (array, property) => {
    return array.reduce((memo, x) => {
        if (!memo[x[property]])
            memo[x[property]] = [];
        memo[x[property]].push(x);
        return memo;
    }, {});
};
exports.groupBy = groupBy;
/**
 * Repeats a function a set amount of times.
 * @param {number} n
 * @param {function} fn
 * @example
 * repeat(3, () => console.log("x")); // xxx
 */
const repeat = (n, fn) => {
    Array(n)
        .fill(undefined)
        .forEach(() => fn());
};
exports.repeat = repeat;
/**
 * Makes a deep clone of an object.
 * @param {any} obj
 */
const cloneObject = (obj) => {
    var clone = {};
    for (var i in obj) {
        if (obj[i] != null && typeof obj[i] == "object")
            clone[i] = (0, exports.cloneObject)(obj[i]);
        else
            clone[i] = obj[i];
    }
    return clone;
};
exports.cloneObject = cloneObject;
/**
 * Creates an array of a certain length filled with a specified value.
 * @param {number} length
 * @param {any} value
 * @example
 * generateArray(3, []); // [[], [], []]
 */
const generateArray = (length, value) => {
    return JSON.parse(JSON.stringify(Array.from({ length }, () => value)));
};
exports.generateArray = generateArray;
/**
 * Returns the last `N` elements of an array. If 1 is specified, it returns only the last element.
 * @param {any[]} arr
 * @param {number} n
 * @example
 * end(2, [1, 2, 3]); // [2, 3]
 */
const end = (arr, n) => {
    const slice = arr.slice(arr.length - n);
    if (n === 1)
        return slice[0];
    return slice;
};
exports.end = end;
/**
 * Returns the month of a provided date in the long format.
 * @param {Date | null} date
 */
const getMonth = (date) => {
    if (date)
        return date.toLocaleString("en", { month: "long" });
    return new Date().toLocaleString("en", { month: "long" });
};
exports.getMonth = getMonth;
/**
 * Calculates the difference in months between two dates.
 * @param {Date} from
 * @param {Date} to
 */
const monthDiff = (from, to) => {
    return (to.getMonth() -
        from.getMonth() +
        12 * (to.getFullYear() - from.getFullYear()));
};
exports.monthDiff = monthDiff;
/**
 * Creates a string that describes the difference between two dates.
 * @param {Date} from
 * @param {Date} to
 */
const dateDiffReadable = (from, to) => {
    const monthDifference = (0, exports.monthDiff)(from, to);
    const years = Math.floor(monthDifference / 12);
    const months = monthDifference % 12;
    return `${years > 0 ? `${years} year${years > 1 ? "s" : ""}` : ""}${months > 0
        ? `${years > 0 ? " " : ""}${months} month${months > 1 ? "s" : ""}`
        : ""}`;
};
exports.dateDiffReadable = dateDiffReadable;
/**
 * Gets a random integer between an inclusive range.
 * @param {number} min
 * @param {number} max
 * @example
 * randInt(1, 20); // 18
 */
const randInt = (min, max) => {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
};
exports.randInt = randInt;
/**
 * Gets a random element of an array.
 * @param {any[]} arr
 * @example
 * sample([1, 2, 3]); // 2
 */
const sample = (arr) => arr[(0, exports.randInt)(0, arr.length - 1)];
exports.sample = sample;
/**
 * Generates a string composed of `n` random characters.
 * @param {number} n
 * @example
 * generateRandomString(5); // "AXRF0"
 */
const generateRandomString = (n) => {
    const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
    let res = "";
    while (n--)
        res += (0, exports.sample)(characters.split(""));
    return res;
};
exports.generateRandomString = generateRandomString;
/**
 * Combines two arrays into one, similar to the Python `zip` function.
 * @see https://docs.python.org/3.3/library/functions.html#zip
 * @param {any[]} a
 * @param {any[]} b
 * @example
 * const a = [1, 2, 3];
 * const b = ["a", "b", "c"];
 * zip(a, b); // [[1, "a"], [2, "b"], [3, "c"]]
 */
const zip = (a, b) => {
    const res = [];
    a.forEach((e, i) => {
        if (b[i])
            res.push([e, b[i]]);
    });
    return res;
};
exports.zip = zip;
/**
 * Gets an array that contains the elements that are present in the array `a`, but not in the array `b`.
 * @param {any[]} a
 * @param {any[]} b
 * @example
 * difference([1, 2, 3], [2, 3, 4]); // [1]
 */
const difference = (a, b) => [...a].filter((x) => [...b].indexOf(x) < 0);
exports.difference = difference;
/**
 * Gets the number of elements in an array that conform to the given condition.
 * @param {any[]} arr
 * @param {Function} condition
 * @example
 * count([1, 2, 3], (x) => x > 2); // 1
 */
const count = (arr, condition) => arr.filter(condition).length;
exports.count = count;
/**
 * Abbreviates large numbers with SI symbols.
 * @param {number} val
 * @example
 * abbreviateNumber(14568); // "14.6k"
 */
const abbreviateNumber = (val) => {
    const tier = (Math.log10(Math.abs(val)) / 3) | 0;
    if (tier === 0)
        return val.toString();
    const suffix = constants_1.SI_SYMBOL[tier];
    const scale = Math.pow(10, tier * 3);
    const scaled = val / scale;
    return scaled.toFixed(1) + suffix;
};
exports.abbreviateNumber = abbreviateNumber;
/**
 * Creates an acronym of a given string.
 * @param {string} txt
 * @example
 * acronym("Sir Isaac Newton"); // "SIN"
 */
const acronym = (txt) => txt
    .split(" ")
    .map((item) => item[0])
    .join("");
exports.acronym = acronym;
/**
 * Finds the common elements of two arrays.
 * @param {any[]} a
 * @param {any[]} b
 * @example
 * common([1, 2, 3], [2, 3, 4]); // [2, 3]
 */
const common = (a, b) => a.filter((e) => b.includes(e));
exports.common = common;
/*
 * Creates a random hex color value.
 * @example
 * randomColorHex(); // "#2a30fd"
 */
const randomColorHex = () => "#000000".replace(/0/g, () => (~~(Math.random() * 16)).toString(16));
exports.randomColorHex = randomColorHex;
/**
 * Cuts a text off at a certain length, ending it with three dots.
 * @param {string} text
 * @param {number} length
 * @example
 * textEllipsis("hello", 3); // "hel..."
 */
const textEllipsis = (text, length) => {
    if (text) {
        if (text.length <= length)
            return text;
        return `${text.substring(0, length)}...`;
    }
    return "";
};
exports.textEllipsis = textEllipsis;
/**
 * Lightens or darkens a hex color value by a certain percentage, negatives values for darker and positive ones for lighter tones.
 * @param {string} color
 * @param {number} percent
 * @example
 * shadeColor("#c72c2c", -40); // "#771a1a"
 * shadeColor("#c72c2c", 40); // "#ff3d3d"
 */
function shadeColor(color, percent) {
    if (color) {
        let R = parseInt(color.substring(1, 3), 16);
        let G = parseInt(color.substring(3, 5), 16);
        let B = parseInt(color.substring(5, 7), 16);
        R = parseInt(((R * (100 + percent)) / 100).toString());
        G = parseInt(((G * (100 + percent)) / 100).toString());
        B = parseInt(((B * (100 + percent)) / 100).toString());
        R = R < 255 ? R : 255;
        G = G < 255 ? G : 255;
        B = B < 255 ? B : 255;
        const RR = R.toString(16).length == 1 ? "0" + R.toString(16) : R.toString(16);
        const GG = G.toString(16).length == 1 ? "0" + G.toString(16) : G.toString(16);
        const BB = B.toString(16).length == 1 ? "0" + B.toString(16) : B.toString(16);
        return "#" + RR + GG + BB;
    }
    return "#000000";
}
exports.shadeColor = shadeColor;
/**
 * Purges the provided array of falsy values.
 * @param {any[]} arr
 * @example
 * onlyTruthy([1, 2, 3, false, undefined, 4]); // [1, 2, 3, 4]
 */
const onlyTruthy = (arr) => arr.filter((e) => !!e);
exports.onlyTruthy = onlyTruthy;
/**
 * Purges the provided array of truthy values.
 * @param {any[]} arr
 * @example
 * onlyFalsy([1, 2, 3, false, undefined, 4]); // [false, undefined]
 */
const onlyFalsy = (arr) => arr.filter((e) => !!!e);
exports.onlyFalsy = onlyFalsy;
/**
 * Calculates the difference of an unspecified amount of inputs.
 * @param {...number} args
 * @example
 * diff(1, 2, 3); // -4
 */
const diff = (...args) => args.reduce((a, b) => a - b);
exports.diff = diff;
/**
 * Divides an unspecified amount of inputs.
 * @param {...number} args
 * @example
 * div(1, 2, 3); // 0.1666666666666667
 */
const div = (...args) => args.reduce((a, b) => a / b);
exports.div = div;
